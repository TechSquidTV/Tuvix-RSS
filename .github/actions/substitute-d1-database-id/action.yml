name: 'Substitute D1 Database ID'
description: 'Substitutes D1_DATABASE_ID placeholder in wrangler.toml'

inputs:
  wrangler-toml-path:
    description: 'Path to wrangler.toml file'
    required: false
    default: 'packages/api/wrangler.toml'
  d1-database-id:
    description: 'D1 Database ID secret'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Substitute D1 database ID
      shell: bash
      env:
        D1_DATABASE_ID: ${{ inputs.d1-database-id }}
      run: |
        set -e  # Exit on any error
        set -u  # Exit on undefined variables
        
        # Store absolute path to wrangler.toml for consistency
        WRANGLER_TOML_PATH=$(cd "$(dirname "${{ inputs.wrangler-toml-path }}")" && pwd)/$(basename "${{ inputs.wrangler-toml-path }}")
        
        # Verify required commands are available
        if ! command -v envsubst >/dev/null 2>&1; then
          echo "::error::envsubst command not found. This is required for substitution."
          exit 1
        fi
        
        if ! command -v python3 >/dev/null 2>&1; then
          echo "::error::python3 command not found. This is required for cleanup."
          exit 1
        fi
        
        # Verify file exists
        if [ ! -f "$WRANGLER_TOML_PATH" ]; then
          echo "::error::wrangler.toml file not found at: $WRANGLER_TOML_PATH"
          exit 1
        fi
        
        # Verify secret is set (without leaking value)
        if [ -z "$D1_DATABASE_ID" ]; then
          echo "::error::D1_DATABASE_ID secret is not set"
          exit 1
        fi
        
        # Trim any whitespace from the database ID value (prevents issues with secret formatting)
        # Use parameter expansion instead of xargs to avoid quote issues
        D1_DATABASE_ID="${D1_DATABASE_ID#"${D1_DATABASE_ID%%[![:space:]]*}"}"  # Remove leading whitespace
        D1_DATABASE_ID="${D1_DATABASE_ID%"${D1_DATABASE_ID##*[![:space:]]}"}"  # Remove trailing whitespace
        
        # Verify the trimmed value is not empty
        if [ -z "$D1_DATABASE_ID" ]; then
          echo "::error::D1_DATABASE_ID is empty after trimming"
          exit 1
        fi
        
        # Verify placeholder exists in file
        if ! grep -q '\${D1_DATABASE_ID}' "$WRANGLER_TOML_PATH"; then
          echo "::error::Placeholder \${D1_DATABASE_ID} not found in wrangler.toml"
          exit 1
        fi
        
        # Export D1_DATABASE_ID for envsubst (it's already in env, but ensure it's available)
        export D1_DATABASE_ID
        
        # Perform substitution with explicit variable list
        envsubst '$D1_DATABASE_ID' < "$WRANGLER_TOML_PATH" > "$WRANGLER_TOML_PATH".tmp
        
        # Verify substitution succeeded (placeholder should be gone)
        if grep -q '\${D1_DATABASE_ID}' "$WRANGLER_TOML_PATH".tmp; then
          echo "::error::Substitution failed - placeholder still present"
          exit 1
        fi
        
        # Verify database_id is not empty after substitution
        if grep -q 'database_id = ""' "$WRANGLER_TOML_PATH".tmp; then
          echo "::error::database_id is empty after substitution"
          exit 1
        fi
        
        # Clean up the database_id line using Python - ensures proper TOML formatting
        # This fixes any trailing whitespace or characters that might cause TOML parsing errors
        echo "ðŸ”§ Cleaning database_id line with Python..."
        
        # Export WRANGLER_TOML_PATH for Python script
        export WRANGLER_TOML_PATH
        
        # Create Python script in a temporary file to avoid YAML linting issues
        PYTHON_SCRIPT_FILE=$(mktemp)
        if [ -z "$PYTHON_SCRIPT_FILE" ]; then
          echo "::error::Failed to create temporary file"
          exit 1
        fi
        cat > "$PYTHON_SCRIPT_FILE.tmp" << 'EOF'
        import re
        import sys
        import os
        
        # Get file path from environment
        file_path = os.environ.get('WRANGLER_TOML_PATH')
        if not file_path:
            print('::error::WRANGLER_TOML_PATH environment variable not set')
            sys.exit(1)
        
        file_path = file_path + '.tmp'
        
        # Verify temp file exists
        if not os.path.exists(file_path):
            print(f'::error::Temporary file not found: {file_path}')
            sys.exit(1)
        
        # Read the file as text
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f'::error::Failed to read file: {e}')
            sys.exit(1)
        
        # Split into lines (preserve newlines in processing)
        lines = content.splitlines(keepends=False)
        
        found = False
        for i, line in enumerate(lines):
            # Check if this is the database_id line (strip to handle whitespace)
            stripped = line.strip()
            if stripped.startswith('database_id = '):
                # Extract the value using regex - handle any whitespace around =
                match = re.search(r'database_id\s*=\s*"([^"]+)"', line)
                if match:
                    db_value = match.group(1).strip()
                    if not db_value:
                        print('::error::database_id value is empty')
                        sys.exit(1)
                    
                    # Get indentation from original line (before stripping)
                    indent_match = re.match(r'^(\s*)', line)
                    indent_str = indent_match.group(1) if indent_match else ''
                    
                    # Create clean line: exactly "database_id = "value"" with no trailing content
                    lines[i] = f'{indent_str}database_id = "{db_value}"'
                    print(f'âœ… Fixed line {i+1} (value length: {len(db_value)}, indent: {len(indent_str)})')
                    found = True
                    break
        
        if not found:
            print('::error::database_id line not found in file')
            sys.exit(1)
        
        # Join lines with newlines and write back
        # Ensure each line ends with exactly one newline
        output = '\n'.join(lines)
        # Ensure file ends with exactly one newline (TOML requirement)
        if output and not output.endswith('\n'):
            output += '\n'
        
        # Write back the file
        try:
            with open(file_path, 'w', encoding='utf-8', newline='\n') as f:
                f.write(output)
        except Exception as e:
            print(f'::error::Failed to write file: {e}')
            sys.exit(1)
        EOF
        # Strip leading 8 spaces from each line to fix indentation
        if ! sed 's/^        //' "$PYTHON_SCRIPT_FILE.tmp" > "$PYTHON_SCRIPT_FILE"; then
          echo "::error::Failed to process Python script"
          rm -f "$PYTHON_SCRIPT_FILE.tmp" "$PYTHON_SCRIPT_FILE"
          exit 1
        fi
        rm -f "$PYTHON_SCRIPT_FILE.tmp"
        
        # Run Python script
        python3 "$PYTHON_SCRIPT_FILE"
        PYTHON_EXIT_CODE=$?
        
        # Clean up temporary Python script
        rm -f "$PYTHON_SCRIPT_FILE"
        
        if [ $PYTHON_EXIT_CODE -ne 0 ]; then
          echo "::error::Python cleanup failed with exit code $PYTHON_EXIT_CODE"
          exit 1
        fi
        
        # Verify temp file still exists after Python processing
        if [ ! -f "$WRANGLER_TOML_PATH".tmp ]; then
          echo "::error::Temporary file disappeared after Python processing"
          exit 1
        fi
        
        # Verify the line is properly formatted (no trailing content after quote)
        # Match: optional whitespace, database_id, optional whitespace, =, optional whitespace, ", value, ", optional whitespace, end of line
        if ! grep -qE '^[[:space:]]*database_id[[:space:]]*=[[:space:]]*"[^"]*"[[:space:]]*$' "$WRANGLER_TOML_PATH".tmp; then
          echo "::error::database_id line format verification failed"
          echo "Actual line content (with visible characters):"
          grep -E '^\s*database_id\s*=' "$WRANGLER_TOML_PATH".tmp | cat -A || true
          echo "Hex dump of the line:"
          grep -E '^\s*database_id\s*=' "$WRANGLER_TOML_PATH".tmp | od -An -tx1 || true
          exit 1
        fi
        
        # Verify database_id value is not empty (double-check)
        DB_VALUE_CHECK=$(grep -E '^\s*database_id\s*=' "$WRANGLER_TOML_PATH".tmp | sed -E 's/^[[:space:]]*database_id[[:space:]]*=[[:space:]]*"([^"]*)".*/\1/')
        if [ -z "$DB_VALUE_CHECK" ]; then
          echo "::error::database_id value is empty after cleanup"
          exit 1
        fi
        
        echo "âœ… Line cleaned and verified successfully"
        
        # Final verification: ensure the line exists and has content
        if ! grep -qE '^\s*database_id\s*=\s*"[^"]+"' "$WRANGLER_TOML_PATH".tmp; then
          echo "::error::Final verification failed - database_id line missing or malformed"
          echo "File content around database_id:"
          grep -A 3 -B 3 'database_id' "$WRANGLER_TOML_PATH".tmp || echo "No database_id line found"
          exit 1
        fi
        
        # Move substituted file into place (using absolute path for consistency)
        # Note: TOML syntax will be validated by wrangler during deployment
        mv "$WRANGLER_TOML_PATH".tmp "$WRANGLER_TOML_PATH"
        echo "âœ… File moved successfully"
        
        echo "âœ… Successfully substituted D1_DATABASE_ID (value not logged for security)"
